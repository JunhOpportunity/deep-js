### Closure (23.07.05)

> **반환된 내부함수가 자신이 선언됐을 때의 환경(Lexical environment)인 스코프를 기억하여 자신이 선언됐을 때의 환경(스코프) 밖에서 호출되어도 그 환경(스코프)에 접근할 수 있는 함수
⇒ 자신이 생성될 때의 환경(Lexical environment)을 기억하는 함수**
> 

**스코프는 함수를 호출할 때가 아니라 함수를 어디에 선언 하였는지에 따라 결정된다. 이를 [렉시컬 스코핑(Lexical scoping)](https://poiemaweb.com/js-scope#7-%EB%A0%89%EC%8B%9C%EC%BB%AC-%EC%8A%A4%EC%BD%94%ED%94%84)라 한다.**
아래 코드를 보면 함수 내에 내부함수가 선언되고 호출되었는데 내부 함수가 외부함수의 변수를 매개변수 전달 없이 사용했다.

```jsx
function outerFunc() {
  var x = 10;
  var innerFunc = function () { console.log(x); };
  innerFunc();
}

outerFunc(); // 10
```

내부함수가 유효한 상태에서 외부함수가 종료하여 외부함수의 실행 컨텍스트가 반환되어도, 외부함수 실행 컨텍스트 내의 **활성 객체(Activation object)**(변수, 함수 선언 등의 정보를 가지고 있다)는 **내부함수에 의해 참조되는 한 유효**하여 내부함수가 **스코프 체인**을 통해 참조할 수 있다
⇒ 외부함수가 이미 반환되었어도 외부함수 내의 변수는 이를 필요로 하는 내부 함수가 하나 이상 존재하는 경우 계속 유지된다. **이때 외부 함수에 있는 변수는 복사본이 아니라 실제 변수이다.**

**closure 활용**

클로저는 자신이 생성될 때의 환경(Lexical environment)을 기억해야 하므로 메모리 차원에서 손해를 볼 수 있다. 하지만 클로저는 자바스크립트의 강력한 기능으로 이를 적극적으로 사용해야 한다.

상태 유지에 매우 유용하다.
그렇다면 클로저 함수가 리엑트에도 쓰일까?

⇒ useState 는 이전 상태와 현재 상태의 변경을 감지하기 위해 함수가 실행되었을 때 이전 상태를 가지고 있어야 하기 때문에 클로저가 사용된다.