## 즉시 실행 함수 표현식(IIFE) (23.07.26)

> 정의 되자마자 즉시 실행되는 함수 표현식
> 

```jsx
(function() {
    console.log('함수 호출');
}());
```

### **활용 문법**

1. **논리 부정 연산자(!)**
**함수는 undefined를 반환**하며 논리 부정 연산자에 의해 true 값이 되기 때문에 즉시 실행되는 원리이다. 그러나 리턴값은 없어야 한다.
    
    ```jsx
    !function() {
    	console.log("! ! !");
    }();
    ```
    
2. **괄호 문법 ← 가장 많이 쓰인다**
함수 선언문을 괄호 기호로 둘러싸고 함수를 호출하는 괄호를 붙여 즉시 실행
    
    ```jsx
    (function() {
        console.log('()() ()() ()()');
    })**()**;
    ```
    
3. **더글라스 문법**
괄호 문법과의 차이점은 닫는 괄호 부분을 어디에 두느냐의 차이
    
    ```jsx
    (function() {
      console.log('(()) (()) (())');
    }**()**);
    ```
    

### 사용 이유

1. **클로저 구현**
    
    ```jsx
    let func = (function() {
      var counter = 0;
          
      return function(){ // 클로저
        return ++counter; 
      }
    })();
    ```
    
2. **async / await 비동기 처리를 바로 사용**
모든 코드를 함수로 묶고 호출하는 방식은 가독성 측면에서 좋지 않을 수 있다. 따라서 만일 이를 별도의 함수 호출이 아닌 일반 코드 실행과 같이 즉시 실행을 하고 싶은 경우 다음과 같이 async function을 정의하고 즉시 호출하기도 한다. 이는 정말 자주 사용되는 기법 이기도 하다.
    
    ```jsx
    (async () => {
      ... 코드1
      await promise();
      ... 코드2
    })();
    ```
    
3. **전역 변수 충돌을 방지하고 싶을때**
즉시 실행 함수의 진정한 장점은 스코프를 제한하고 전역 변수 충돌을 방지하는 데 사용되어 모듈 패턴을 구현하는 데 있다. IIFE를 사용하면 함수 내에서 변수를 지정하는 것과 같아, 변수가 IIFE 내에서만 유효하다. 따라서 변수 충돌 문제를 방지할 수 있다.
⇒ 일회성 변수가 필요하면 전역 변수로 선언하지 않고 안전하게 지역 변수로 다루어 해결이 가능해진다.
    
    ```jsx
    (function() {
      var x = 10;
      console.log(x); // Output: 10
    })();
    console.log(x); // Output: ReferenceError: x is not defined
    ```
    